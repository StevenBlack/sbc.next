---
layout: post
title: "Text and String Handling in VFP"
author: "Steven Black"
type: ""
header_text: ""
lead_text: ""
excerpt: ""
category: 
tags: []

---
<h2>Introduction</h2>

<p>This article serves to introduce, illustrate, and explore some of the great ( and not so great ) string handling capabilities of Visual FoxPro.</p>

<p>I always seem to be involved with solving many text-data related problems in my VFP projects. On the surface, handling text isnt very sexy and seemingly
not very interesting. I think otherwise, and I hope youll agree.</p>

<p>This document is split into three sections: <em>Inbound</em> is about getting text into the VFP environment so you
can work with it. <em>Processing</em> is about manipulating the text, and <em>Outbound</em>
is about sending text on its way when youre done.</p>

<p>To illustrate text handling in VFP, I am using the complete text of Tolstoys <em>War And Peace</em>, included on
the conference CD as WarAndPeace.TXT, which along with thousands of works of literature, are available on the web, including
<a href="http://altair.stmarys-ca.edu/studwork/integral/warandpe.txt">here</a> among others.</p>

<p>This article was originally written using Visual FoxPro version 6, and has since been updated for VFP 7 and VFP 8.</p>

<p><strong>Some facts about VFP strings</strong></p>

<p>Here are a few things you need to know about VFP strings:</p>

<p> In functional terms, there is no difference between a character field and a memo field. All functions
that work on characters also work on memos.</p>

<p> The maximum number of characters that VFP can handle in a string is 16, 777, 184.</p>

<h2>Inbound</h2>

<p>This section is all about getting text into your processing environment.</p>

<h3>Inbound text from table fields</h3>

<p>To <strong>retrieve text from a table field</strong>, simply assign it to a memory variable.</p>

<pre>
	CREATE TABLE Ships ( Name C( 40 ), Desc M )
	INSERT INTO Ships ( Name, Desc ) VALUES( Exxon Valdez, Billions unpaid! )
	LOCAL lcShip, lcDesc
	lcShip= Ship.Name
	lcDesc= Ship.Desc

	* Note that it doesn't matter if the field is type Character or Memo.
</pre>

<h3>Inbound from text files</h3>

<p>There are many ways to retrieve text from files on disk.</p>

<p><strong>FILETOSTR( cFileName )</strong> is used to place the contents of a disk file into a string memory variable. This is among my favorite new functions
in VFP 6. Its both useful and fast. For example, the following code executes in one-seventh of a second on my 220Mhz Pentium laptop.</p>

<pre>
	LOCAL t1, t2, x
	t1= SECONDS()
	x= FILETOSTR( WarAndPeace.TXT )   <strong>&amp;&amp; 3.2 mb in size</strong>
	t2= SECONDS()
	?t2-t1, seconds    <strong>&amp;&amp; 0.140 ( seconds )</strong>
	?len( x )   <strong>&amp;&amp; 3271933</strong>
</pre>

<p>In other words, on a very modest laptop ( by todays standards ) VFP can load the full text from Tolstoys <em>War And
Peace</em> in one-seventh of a second.</p>

<p><strong>Low Level File Functions ( LLFF )</strong> are somewhat more cumbersome but offer great control. LLFF are also very fast. The following example
reads the entire contents of Tolstoys <em>War And Peace</em> from disk into memory:</p>

<pre>
	LOCAL t1, t2, x, h
	t1= SECONDS()
	h= FOPEN( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	x= FREAD( h, 4000000 )
	t2= SECONDS()
	?t2-t1, "seconds"  <strong>&amp;&amp; 0.140 seconds</strong>
	?LEN( x )   <strong>&amp;&amp; 3271933</strong>
	FCLOSE( h )
</pre>

<p>Given the similar execution times, I think we can conclude that internally, LLFF and <strong>FILETOSTR()</strong> are implemented similarly. However
with the LLFF we also have fine control. For example, <strong>FGETS()</strong> allows us to read a line at a time. To illustrate, the following
code reads the first 15 lines of <em>War And Peace</em> into array <strong>wpLines</strong>.</p>

<pre>
	LOCAL t1, t2, i, h
	LOCAL ARRAY wpLines[15]
	CLEAR
	t1= SECONDS()
	h= FOPEN( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	FOR i= 1 TO ALEN( wpLines )
	  wpLines[i]= FGETS( h )
	ENDFOR
	t2= SECONDS()
	?t2-t1, "seconds"   <strong>&amp;&amp; 0.000 seconds</strong>

	FOR i= 1 TO ALEN( wpLines )
	  ? wpLines[i]
	ENDFOR
	FCLOSE( h )
</pre>

<p>We can also retrieve a segment from <em>War And Peace. </em><strong>FSEEK()</strong> moves the LLFF pointer, and
the <strong>FREAD()</strong> function is used to read a range. Lets read, say, 1000 bytes about half way through the book.</p>

<pre>
	LOCAL t1, t2, x, h
	LOCAL ARRAY wpLines[15]
	CLEAR
	t1= SECONDS()
	h= FOPEN( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	FSEEK( h, 1500000 )  <strong>&amp;&amp; Move the pointer</strong>
	x=FREAD( h, 1000 )  <strong>&amp;&amp; Read 1000 bytes</strong>
	t2= SECONDS()
	?t2-t1, "seconds"   <strong>&amp;&amp; 0.000 seconds</strong>
	SET MEMOWIDTH TO 8000
	?x
	FCLOSE( h )
</pre>

<h3>Inbound from text files, with pre-processing</h3>

<p>Sometimes you need to pre-process text before it is usable. For example, you may have an HTML file from which you need to clean and remove tags. Or
maybe you have the problem exhibited by our copy of <em>War and Peace</em>, which has embedded hard-returns at the end
of each line. How can we create a streaming document that we can actually format?</p>

<p>Often the answer is to use the <strong>APPEND FROM</strong> command, which imports from file into a table, and moreover supports a large variety of
file formats. The strategy always works something like this: You create a single-field table, and you use <strong>APPEND FROM ... TYPE SDF</strong> to
load it</p>

<pre>
	LOCAL t1, t2
	CLEAR
	t1= SECONDS()
	CREATE TABLE Temp ( cLine C ( 254 ))
	APPEND FROM WarAndPeace.Txt TYPE SDF
	t2= SECONDS()
</pre>
<pre>
?t2-t1, "seconds"  <strong>&amp;&amp; 1.122 seconds</strong>
</pre>

<p>Now youre good to go: Youve got a table of records that you can manipulate and transform to your hearts content using VFPs vast collection of functions.</p>

<h2>Processing</h2>

<p>This section discusses a wide variety of string manipulation techniques in Visual FoxPro. Lets say weve got some text in our environment, now lets
muck with it.</p>

<h3>Does a sub-string exist?</h3>

<p>There are many ways to determine if a sub-string exists in a string. The <strong>$</strong> command returns True or False if a sub-string is contained
in a string. This command is fast. Try this:</p>

<pre>
	LOCAL t1, t2, x
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	t1= SECONDS()
	? "THE END" $ x
	t2= SECONDS()
	?[ "THE END" $ x], t2-t1, "seconds"    <strong>&amp;&amp; 0.180 seconds</strong>
</pre>

<p>The <strong>AT()</strong>and <strong>ATC()</strong>functions are also great for determining if a sub-string exists, the former having the advantage
of being case insensitive and, moreover, their return values gives you an exact position of the sub-string.</p>

<pre>
	LOCAL t1, t2, x, lnAtPos
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	t1= SECONDS()
	lnAtPos=ATC( "the end", x )
	t2= SECONDS()
</pre>
<pre>
	?lnAtPos           <strong>&amp;&amp; 97837</strong>
	?[ATC( "the end", x )], t2-t1, "seconds"    <strong>&amp;&amp; 0.110 seconds</strong>
	?SUBS( x, lnAtPos, 20 )   <strong>&amp;&amp;  the end of it...</strong>
</pre>

<p>The <strong>OCCURS()</strong> function will also tell you if a sub-string exists, and moreover tell you how many times the sub-string occurs. This
code will count the number of occurrences of a variety of sub-strings in <em>War And Peace</em>.</p>

<pre>
	LOCAL t1, t2, x, i
	LOCAL ARRAY aStrings[5]
	aStrings[1]= "Russia"  <strong>&amp;&amp; 775 occurences</strong>
	aStrings[2]= "Anna"    <strong>&amp;&amp; 293 occurences</strong>
	aStrings[3]= "Czar"    <strong>&amp;&amp; 4 occurences</strong>
	aStrings[4]= "windows" <strong>&amp;&amp; 23 occurences</strong>
	aStrings[5]= "Pentium" <strong>&amp;&amp; 0 occurences</strong>
</pre>
<pre>
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	FOR i = 1 TO ALEN( aStrings )
		t1= SECONDS()
		?OCCURS( aStrings[i], x )
		t2= SECONDS()
		?[OCCURS( "]+aStrings[i]+[", x )], t2-t1, "seconds"  <strong>&amp;&amp; 0.401 seconds avg</strong>
	ENDFOR
</pre>

<p>Locating sub-strings in strings is something VFP does really well.</p>

<h3>Locating sub-strings</h3>

<p>One of the basic tasks in almost any string manipulation is locating sub strings within larger strings. Four useful functions for this are <strong>
AT()</strong>, <strong>RAT()</strong>, <strong>ATC()</strong>, and <strong>RATC()</strong>. These locate the ordinal position of sub-strings locating
from the left ( <strong>AT()</strong> ), from the right ( <strong>RAT()</strong> ), both of which have case-insensitive variants ( <strong>ATC()</strong>,
and <strong>RATC()</strong> ). All these functions are very fast and scale well with file size. For example, lets go look for THE END in
<em>War And Peace</em>.</p>

<pre>
	LOCAL t1, t2, x
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	t1= SECONDS()
	?AT( "THE END", x )   <strong>&amp;&amp; 3271915</strong>
	t2= SECONDS()
	?[AT( "THE END", x )], t2-t1, , "seconds"    <strong>&amp;&amp; 0.180 seconds</strong>
</pre>

<p>You can also check for the <strong>n</strong>th occurrence of a sub-string, as illustrated below where we find the 1st, 101st, 201st...701st occurrence
of the word Russia in <em>War And Peace</em>.</p>

<pre>
	LOCAL t1, t2, x, i, nOcc
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	FOR i= 0 TO 7
	  nOcc= i*100+1
	  t1= SECONDS()
	  ?AT( "Russia", x, nOcc  )
	  t2= SECONDS()
	  ?[AT( "Russia", x, ]+Transform( nOcc )+[ )], t2-t1  <strong>&amp;&amp; 0.180 sec on average</strong>
	ENDFOR
</pre>

<p>Two other functions are useful for locating strings: <strong>ATLINE()</strong> and <strong>ATCLINE()</strong>. These return the line number of the
first occurrence of a string. </p>

<div class="info">
      <p>Note: Prior to VFP 7, functions that are sensitive to <strong>SET MEMOWIDTH</strong>, like <strong>ATLINE()</strong> and <strong>ATCLINE()</strong><strong>, among
      </strong>among others<strong>, </strong> are dog-slow on larger strings and so do not scale well at all.</p>
</div>

<h3>Traversing text line-by-line</h3>

<p>Iterating through text, one line at a time, is a common task. Heres the way VFP developers have been doing it for years: Using the <strong>MEMLINES()</strong>
and <strong>MLINE()</strong> functions. Like this:</p>

<pre>
	LOCAL x, y, i, t1, t2
	SET MEMOWIDTH TO 8000
	x=FILETOSTR( home()+"Genhtml.prg" )  <strong>&amp;&amp; 767 lines</strong>
</pre>
<pre>
	t1=SECONDS()
	FOR i= 1 TO MEMLINES( x )
		y=MLINE( x, i )
	ENDFOR
</pre>
<pre>
	t2=SECONDS()
	?"Using MLINE()", t2-t1, "seconds"  <strong>&amp;&amp; 22.151 seconds</strong>
</pre>

<p>Thats pathetic performance. 20+ seconds to iterate through 767 lines! Fortunately, theres a trick to using <strong>MLINE()</strong>, which is
to pass the <strong>_MLINE</strong> system memory variable as the third parameter. Like this.</p>

<pre>
	LOCAL x, y, i, t1, t2
	SET MEMOWIDTH TO 8000
	x=FILETOSTR( home()+"Genhtml.prg" )  <strong>&amp;&amp; 767 lines</strong>
</pre>
<pre>
	t1=SECONDS()
	_mline=0
	FOR i= 1 TO MEMLINES( x )
		y=MLINE( x, 1, _MLINE )
	ENDFOR
</pre>
<pre>
	t2=SECONDS()
	?"Using MLINE() with _MLINE", SECONDS()-z, "seconds"  <strong>&amp;&amp; 0.451 seconds</strong>
</pre>

<p>Now thats more like it a fifty-fold improvement. A surprising number of VFP developers dont know this idiom with <strong>_MLINE</strong> even
though its been documented in the FoxPro help since version 2 at least.</p>

<p>Starting in VFP 6 all this is obsolete, since <strong>ALINES()</strong> is a screaming new addition to the language. Lets see how these routines
look and perform with <strong>ALINES()</strong>.</p>

<pre>
	LOCAL x, i, y, ti, t2
	LOCAL ARRAY laArray[1]
	x=FILETOSTR( home()+"Genhtml.prg" )  <strong>&amp;&amp; 767 lines</strong>


	t1=SECONDS()
	FOR i= 1 TO ALINES( laArray, x )
	 y=laArray[i]
	ENDFOR
	t2=SECONDS()

	?"Using ALINES() and traverse array:", t2-t1, "seconds"  <strong>&amp;&amp; 0.020 seconds</strong>
</pre>

<p>Another twenty-fold improvement in speed. I think the lesion is clear: If you are using <strong>MLINE()</strong> in your applications, and you
are using VFP 6, then its time to switch to <strong>ALINES()</strong>. There are just two major differences: First, <strong>ALINES()</strong> is limited
by VFPs 65, 000 array element limit, and second, successive lines with only <strong>CHR( 13 )</strong> carriage returns are considered as one line.
For example:</p>

<pre>
	lcSource = "How~~Many~~Lines?~"
	lcString = STRTRAN( lcSource, "~", CHR( 13 ))
	?ALINES( aParms, lcstring )   &amp;&amp; 3
</pre>

<p>But if you use carriage return + line feed, <strong>CHR( 13 )+CHR( 10 )</strong>, youll get the results you expect.</p>

<pre>
	lcSource = "How~~Many~~Lines?~"
	lcString = STRTRAN( lcSource, "~", CHR( 13 )+CHR( 10 ))
	?ALINES( aParms, lcstring )   &amp;&amp; 5
</pre>

<p>This is a bit unnerving if blank lines are important, so beware and use <strong>CHR( 13 )+CHR( 10 ) </strong>to avoid this problem.</p>

<p>Now, just for fun, lets rip through <em>War And Peace</em> using <strong>ALINES()</strong>.</p>

<pre>
	LOCAL x, i, y, z, k
	LOCAL ARRAY laArray[1]
	x=FILETOSTR( "WarAndPeace.TXT" )

	t1=SECONDS()
	FOR i= 1 TO ALINES( laArray, x )   <strong>&amp;&amp; 54, 227 array elements</strong>
		y=laArray[i]
	ENDFOR

	t2=SECONDS()
	?"Using ALINES() and traverse", t2-t1, "seconds"  <strong>&amp;&amp; 3.395 seconds</strong>
</pre>

<p>Excuse me, but wow, considering were creating a 54, 337 element array from a file on disk, then were traversing the entire array assigning each elements
contents to a memory variable, and were back in 3.4 seconds.</p>

<p>What about just creating the array of <em>War And Peace</em>:</p>

<pre>
	LOCAL x, t1, t2
	LOCAL ARRAY laArray[1]
	x=FILETOSTR( "WarAndPeace.TXT" )
	t1=SECONDS()
	?ALINES( laArray, x )     <strong>&amp;&amp; 54, 227 array elements</strong>
	t2=SECONDS()
	?"Using ALINES() to load War and Peace", t2-t1, "seconds" <strong>&amp;&amp; 2.203 seconds</strong>
</pre>

<p>So, on my Pentium 233 laptop using VFP 6, we can load <em>War and Peace</em> from disk into a 54, 000-item array in
2.2 seconds. On my newer desktop machine, a Pentium 500, this task is subsecond.</p>

<h3>Traversing text word-by-word</h3>

<p>You could recursively traverse a string word-by-word by using, among other things, the return value from <strong>AT( , x, n )</strong>and <strong>SUBS(
, , )</strong> and, if you are doing that, youre missing a great and little known feature of VFP.</p>

<p>Two new functions are great for word-by-word text processing. The <strong>GETWORDCOUNT()</strong> and <strong>GETWORDNUM()</strong>
functions, return the number of words and individual words respectively.</p>

<div class="info">

      <p>Prior to VFP 7, use the <strong>Words()</strong> and <strong>WordNum()</strong> functions, which are available to you when you load the
      FoxTools.FLL library, return the number of words and individual words respectively.</p>
</div>

<p>Lets see how they perform. Lets first count the words in <em>War And Peace</em>.</p>

<pre>
	LOCAL x, t1, t2
	LOCAL ARRAY laArray[1]
	x=FILETOSTR( "WarAndPeace.TXT" )    <strong>&amp;&amp; 3.2 mb in size</strong>
	t1=SECONDS()
	?GETWORDCOUNT( x )   <strong>&amp;&amp; 565412</strong>t2=SECONDS()

	?"Using GETWORDCOUNT() on War and Peace", t2-t1, "seconds"  <strong>&amp;&amp; 0.825 seconds</strong>
</pre>

<p>The <strong>GETWORDCOUNT()</strong> function is also useful for counting all sorts of tokens since you can pass the
word delimiters in the second parameter. How many sentences are there in <em>War And Peace</em>?</p>

<pre>
	LOCAL x, t1, t2
	LOCAL ARRAY laArray[1]
	x=FILETOSTR( "WarAndPeace.TXT" )    <strong>&amp;&amp; 3.2 mb in size</strong>
	t1=SECONDS()
	?GETWORDCOUNT( x, "." )   <strong>&amp;&amp; ( Note the "." )    26673</strong>
	t2=SECONDS()

	?"Using GETWORDCOUNT() countING sentences in W&amp;p", t2-t1, "seconds"<strong>&amp;&amp; 0.803 seconds</strong>
</pre>

<p><strong>GETWORDNUM()</strong> returns a specific word from a string. Whats the 666th word in War And Peace?
What about the 500000th?</p>

<pre>
	LOCAL x, t1, t2
	x=FILETOSTR( "WarAndPeace.TXT" )    <strong>&amp;&amp; 3.2 mb in size</strong>
	t1=SECONDS()
	?GETWORDNUM( x, 666 )  <strong>&amp;&amp; Anna</strong>
	t2=SECONDS()
</pre>
<pre>
	?"Finding the 666th word in W&amp;P", t2-t1, "seconds"  <strong>&amp;&amp; 0.381 seconds</strong>
	t1=SECONDS()
	?GETWORDNUM( x, 500000 )  <strong>&amp;&amp; his</strong>
	t2=SECONDS()


	?"Finding the 500000th word in W&amp;P", t2-t1, "seconds"  <strong>&amp;&amp; 1.001 seconds</strong>
</pre>

<p>Similarly to <strong>GETWORDCOUNT()</strong>, we can use <strong>GETWORDNUM()</strong>
to return a token from a string by specifying the delimiter. Whats the 2000th sentence in War And Peace? </p>

<pre>
	LOCAL x, t1, t2
	x=FILETOSTR( "WarAndPeace.TXT" )   <strong> &amp;&amp; 3.2 mb in size</strong>
	t1=SECONDS()
	?GETWORDNUM( x, 2000, "." )
	t2=SECONDS()


	?"Finding the 2000th sentence in W&amp;P", t2-t1, "seconds"<strong>&amp;&amp; 0.391 seconds</strong>
</pre>

<h3>Substituting text</h3>

<p>VFP has a number of useful functions for substituting text. <strong>STRTRAN()</strong>, <strong>CHRTRAN()</strong>, <strong>CHRTRANC()</strong>,
<strong>STUFF()</strong>, and <strong>STUFFC()</strong>.</p>

<p><strong>STRTRAN()</strong> replaces occurrences of a string with another. For example, lets change all occurrences of Anna to the McBride twins in
<em>War And Peace</em>.</p>

<pre>
	LOCAL t1, t2, x
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	? "Words in W&amp;P:", WORDS( x )   <strong>&amp;&amp; 565412 words</strong>
	t1= SECONDS()
	x=STRTRAN( x, "Anna", "the McBride twins" )
	t2= SECONDS()
	? t2-t1, "seconds"    <strong>&amp;&amp; 2.314 seconds</strong>

	?Occurs( "the McBride twins", x ), "occurences"  <strong>&amp;&amp; 293 Occurences</strong>
	? "Words in W&amp;P:", WORDS( x )   <strong>&amp;&amp; 565412 words</strong>
</pre>

<p>Thats over 125 replacements per second, which is phenomenal. What about removing strings?</p>

<pre>
	LOCAL t1, t2, x
	x= FILETOSTR( "WarAndPeace.TXT" )  <strong> &amp;&amp; 3.2 mb in size</strong>
	? "Words in W&amp;P:", WORDS( x )      <strong>&amp;&amp; 565412 words</strong>
	t1= SECONDS()
	x=STRTRAN( x, "Anna" )
	t2= SECONDS()
	? t2-t1, "seconds"    <strong>&amp;&amp; 2.293 seconds</strong>
	? "Words in W&amp;P:", WORDS( x )  <strong>&amp;&amp; 565168 words</strong>
</pre>

<p>So it appears that <strong>STRTRAN()</strong> both adds and removes strings with equal aplomb. What of <strong>CHRTRAN()</strong>, which swaps characters?
Lets, say, change all s to ch in <em>War and Peace</em>.</p>

<pre>
	LOCAL t1, t2, x
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	t1= SECONDS()
	x=CHRTRAN( x, "s", "ch" )
	t2= SECONDS()
	? t2-t1, "seconds"    <strong>&amp;&amp; 0.521 seconds</strong>
</pre>

<p>Which isnt bad considering that there are 159, 218 occurrences of character s in <em>War And Peace</em>.</p>

<p>However dont try to use <strong>CHRTRAN()</strong> when the second parameter is an empty string. The performance of <strong>CHRTRAN()</strong> in these
circumstances is terrible. If you need to suppress sub-strings, use <strong>STRTRAN()</strong> instead.</p>

<h3>String Concatenation</h3>

<p>VFP has tremendous concatenation speed if you use it in a particular way. Since many common tasks, like building web pages, involve building documents
one element at a time, you should know that string expressions of the form <strong>x=x+y</strong> are very fast in VFP. Consider this:</p>

<pre>
	LOCAL t1, t2, x
	x= FILETOSTR( "WarAndPeace.TXT" )   &amp;&amp; 3.2 mb in size
	t1= SECONDS()
	x= x+ "&lt;b&gt;Drink Milk!&lt;/b&gt;"
	t2= SECONDS()
	? t2-t1, "seconds"    &amp;&amp; 0.000 seconds
</pre>

<p>The same type of performance applies if you build strings small chunks at a time, which is a typical scenario in dynamic Web pages whether a template
engine or raw output is used. For example:</p>

<pre>
	LOCAL t1, t2, x, y, count
	t1= SECONDS()
	x = ""
	y = "VFP Strings are fast"
	FOR count = 1 to 10000
	    x = x + y
	ENDFOR

	t2= SECONDS()
	? t2-t1, "seconds"    &amp;&amp; 0.030 seconds
	? len( x )            &amp;&amp; 200,000 chars

RETURN
</pre>

<p>This full optimization occurs as long as the string is adding something to itself and as long as the string concatenated is stored in a variable. Using
class properties is somewhat less efficient. String optimization does not occur if the first expression on the right of the = sign is not the same as
the string being concatenated. So:</p>

<pre>
	x = "" + x  + y
</pre>

<p>is not optimized in this fashion. The above line, placed in the example above, takes 25 seconds! So appending strings to strings is blazingly fast
in most common situations.</p>

<h2>Outputting text</h2>

<p>So youve got text, maybe a lot of it, what are your options for writing it to disk.</p>

<p>Foremostly theres the new <strong>STRTOFILE()</strong> function which creates a disk file wit the contents of a string. Lets write
<em>War And Peace</em> to disk.</p>

<pre>
	LOCAL t1, t2, x
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	t1= SECONDS()
	STRTOFILE( x, "Junk.txt" )
	t2= SECONDS()
	? t2-t1, "seconds"    <strong>&amp;&amp; 0.480 seconds</strong>
</pre>

<p>Which means that you can dish 3+ Mb to disk in about a half-second.</p>

<p>You can also use <strong>Low Level File Functions ( LLFF )</strong> to output text. The <strong>FWRITE()</strong> function dumps all or part of a string
to disk. The <strong>FPUTS()</strong> function outputs a single line from the string, and moves the pointer</p>

<pre>
	LOCAL t1, t2, x
	x= FILETOSTR( "WarAndPeace.TXT" )   <strong>&amp;&amp; 3.2 mb in size</strong>
	t1= SECONDS()
	h=FCREATE( "Junk.txt" )
	FWRITE( h, x )
	FCLOSE( h )

	t2= SECONDS()

	? t2-t1, "seconds"    <strong>&amp;&amp; 0.451 seconds</strong></strong>
</pre>

<p>Here again, the similar performance times between <strong>FWRITE()</strong> and <strong>STRTOFILE()</strong> are striking, just as they were when comparing
<strong>FREAD()</strong> and <strong>FILETOSTR()</strong>.</p>

<p>Heres an example of outputting <em>War And Peace</em> line-by-line using <strong>FPUTS()</strong>. Since were
using <strong>ALINES()</strong>, its not that onerous a task. In fact, its very slick!</p>

<pre>
	LOCAL x, h, i, t1, t2
	LOCAL ARRAY laArray[1]

	x=FILETOSTR( "WarAndPeace.TXT" ) <strong>&amp;&amp; 3.2 mb in size</strong>
	t1=SECONDS()
	h=FCREATE( "Junk.txt" )
	FOR i= 1 TO ALINES( laArray, x )
	 FPUTS( h, laArray[i] )
	ENDFOR
	FCLOSE( h )

	t2=SECONDS()
	?"Total time:", t2-t1, "seconds"  <strong>&amp;&amp; 3.595 seconds</strong>
</pre>

<h2>Conclusion</h2>

<p>So, there you have it, a cafeteria-style tour of VFPs text handling capabilities. I personally think that most of the code snippets Ive shown here
have amazing and borderline unbelievable execution speeds. I hope Ive been able to show that VFP really excels at string handling. </p>
